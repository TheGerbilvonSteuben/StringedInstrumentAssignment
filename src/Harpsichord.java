import java.util.ArrayList;

/**
 * Harpsichords with a three-octave range
 * including two octaves below A4 (440Hz).
 *
 * @author Jerret Stovall
 * @version 8/22/2020
 */
public class Harpsichord implements Instrument {

    /** The keyboard layout for this instrument. */
    private String keyboard = Instrument.QWERTY_KEY_MAP;

    /** Frequency of concert A (440Hz). */
    private static final double CONCERT_A = 440.0;
    /** Number of notes in an octave. */
    private static final double NOTES_PER_OCTAVE = 12.0;

    /** Simulate a harpsichord with 37 notes using
     *   a collection of metal strings.*/
    private ArrayList<MetalString> notes;

    /** Array of valid inputs / Maps the keys of the
     *   harpsichord to specific notes.*/
    private char[] keys;
    /** The number of notes that can be played.*/
    private int numberofNotes =
        (int) (Math.round(CONCERT_A / NOTES_PER_OCTAVE));
    /** Index used to map keys to notes.*/
    private int index;
    /**A number used to get past the checkstyle tool. */
    private static final int MAGIC_NUMBER = 24;

    /**
     * Construct a harpsichord object.
     */
    public Harpsichord() {

        // Collections used to map keys to their respective notes.
        this.keys = keyboard.toCharArray();
        this.notes = new ArrayList<>();

        // Initialize all metal strings
        for (int i = 0; i < numberofNotes; i++) {

        // frequency changes to provide the correct
        // input needed to construct each metal string
        // with every iteration of this loop according to the
        // formula: f(i) = standard concert pitch of A * 2^((i -24) / 12)
        double frequency = CONCERT_A
             * (Math.pow(2, ((i - MAGIC_NUMBER) / NOTES_PER_OCTAVE)));
         // Construct a new metal string with a unique frequency.
         MetalString temp = new MetalString(frequency);
         // Add newly constructed metal string
         // to the list of notes
         // that the harpsichord can play.
         notes.add(temp);

        } //End for

    } //End Harpsichord

    /**
     * Determines whether the harpsichord can produce the note associated
     * with the specified key.
     * @param noteChar The specified key to be played.
     * */
    @Override
    public boolean hasNote(final char noteChar) {

        boolean isTrue = false;

        // Iterate through the array of valid keys.
        for (int i = 0; i < numberofNotes; i++) {

            // Find the desired key.
            if (keys[i] == noteChar) {

                isTrue = true;

            } //End if

        } //End for

        // Return false if given key is invalid.
        return isTrue;

    } //End hasNote

    /**
    * Simulates plucking a string.
    * @param noteChar The key specifying the note to be plucked.
    * @throws IllegalArgumentException if the note cannot be played.
    *  specified note.
    */
    @Override
    public void startNote(final char noteChar)
        throws IllegalArgumentException {

        // Check if the note can be played.
        if (!this.hasNote(noteChar)) {

            throw new IllegalArgumentException("Note cannot be"
            + " played on harpsichord:" + noteChar);

        }
        // Find the string that needs to be plucked.
        getIndex(noteChar);
        // Pluck that string.
        notes.get(index).pluck();

    } //End startNote

    /**
     * Simulates the playing of the current sound of the harpsichord.
     * */
    @Override
    public void play() {

        // The sound generated is a composition of the current
        // energy states of all the harpsichord's strings.
        double sum = 0;
        for (int i = 0; i < numberofNotes; i++) {
        sum += notes.get(i).sample();

        } //End for

        // Play the sound currently being generated by the harpsichord.
        StdAudio.play(sum);

    } //End play

    /**
     * Advances the simulation by one time unit.
     * */
    @Override
    public void tick() {

        // Advance all 37 metal strings by one time unit.
        for (int i = 0; i < numberofNotes; i++) {

            notes.get(i).tick();

        } //End for

    } //End tick

    /**
     * Returns the index of the note mapped to the given key.
     * @param key The specified key to be found.
     * */
    private void getIndex(final char key) {

        for (int i = 0; i < numberofNotes; i++) {

            if (keys[i] == key) {

                index = i;

            } //End if

        } //End for

    } //End getIndex

} //End Harpsichord
